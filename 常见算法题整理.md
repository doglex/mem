---
date: 2017-06-12 21:08
status: public
title: 常见算法题整理
---
```

>写函数的话先写测试用例在写功能、考虑容错（边界情况、浮点型比较、字符串比较用equals、类型检测、错误处理）。三种错误处理，返回值、全局变量、异常。编码前先和面试官讲思路。
>没有银弹。虽然这些算法都不是说特别复杂，但是简单的算法面试官就容易计较边界问题，要手写算法的时候可能就需要反复背诵才能一次性写对。
>对于一个特定问题，解决好他的方法往往是简单的。
···
1.判断链表是否重合：考虑双指针法，A到末尾跳到B，B到末尾跳到A，相交的话会在末尾前达到交点。
2.stack里实现min和max：使用辅助栈，或者压入两个值。
3.调整数组顺序使奇数位于偶数前面：若需要保持原顺序，双指针前向探索；不须有序，则前后双指针。
4.100万个整数中选取top100，或者寻找第k大的数：建立一个100大小的小根堆，然后用新的数据跟小根堆根节点比较，如果大则替换；或者用100个桶，一样的，只是清洗效率不大一样；或者快排里有partition。MR中，可以每个map找top100，reduce中再top100。
5.两个有序单链表的合并：不断pop法。//需不需要考虑链表有环，相交等情况？
6.单链表的逆置:两个两个来，三指针法，需要保证一个前向指针不断掉。
7.二分查找及其变种：注意边界，小于等于，如果不是python注意加法溢出。不要用递归，用循环快。end=mid-1,start=mid+1,线性查找。
8.**这题靠记忆力，记住就好了**找二叉树中任意两个节点的最近公共祖先：若是搜索二叉树，要根据大小确定搜索方向；若是普通的二叉树，使用**后序遍历**，经过两个点之后的节点是最近的父节点。
9.循环移位有序数组的二分查找：可以向前则向前，可以向后则向后，之后线性搜索。
10.数据流的中位数：使用两个堆一大一小，小顶堆的都被大顶堆的大。清洗后插入另一个堆。
11.数组最大连续和。前面的部分(current)正则用，不正则更新全局max，同时置零，舍弃前半段开始。
12.快速排序是稳定的还是非稳定的？时间复杂度呢？什么时候最坏复杂度？
不稳定，对数复杂度，有序时最坏平方级（因此排序前一般先随机shuffle一遍）。比如哨兵在第一个位置，都在右半块，那么效率低。
13.贪心的计算思想是什么：每次都做局部最优，不考虑全局，走一步看一步。
14.中序遍历的递归版本和非递归版本：使用栈。主旋律一直向左push，走不动了，pop，添加右节点。
后序遍历：主旋律一直向左push，走不动了，pop，若lastvisit!=right（使用top方法试探），添加右。
层序遍历用队列。
前序边pop变push进右左。
15.找到一棵二叉树中距离最远的两个节点（距离定义为边长）：每次都要经过某个节点，计算这个节点上的距离，更新这个节点的最大路径，更新全局最大距离。递归。
16.堆排序：有sinkdown,swimup。pop的时候提出头，把尾部的拿过来sinkdown，插入的时候进行swim up。
17.一个只含有虚函数的类的size为多少:1
18.http请求类别与get和post区别：一个参数显式在URL中，有长度限制；一个参数隐式，长度理论上可以较大。
19.面向对象语言的三个特征是什么(封装、继承、多态）：封装性，一方面在数据的操作需要通过操作函数，一方面在于这个数据就有了相应的操作；继承性，从父类那里把好用的东西拿过来，不好用的进行重写；多态性，父类的指针，在子类方法上动态绑定，使用时更加不同的具体类似出现不同的行为。
20.二叉搜索树原地转化为有序双链表：使用中序遍历，左节点前向探索。
21.为什么选Python3不选Python2？3和2的区别知道哪些：Python3的字符串采用str类型和bytes类型，Python2混合了str和unicode类型，Python3对中文的支持要方便一些，源文件使用了utf-8编码，编码问题少。print，xrange取消，元组解析方式更多，reduce被弄到某个包里，cPickle之类的取消。
22.TCP需要三次握手，两次行不行？为什么？无论建立还是释放全双工需要4次，而服务器端是默认打开的，所以是3次。不管建立还是释放都是客户端发起的，服务器端一直运行。
23.TCP三次握手：(1)客户端发送SYN(2)服务端发送SYN+ACK(3)客户端发送ACK。 //SYN是同步，ACK是应答
24.TCP四次摆手：(1)客户端发送FIN，进入FIN_WAIT_1(2)服务端发送ACK，进入CLOSE_WAIT，客户端进入FIN_WAIT_2(3)服务端发送FIN(4)客户端发送ACK，进入RIME_WAIT，服务端收到CLOSE
25.TCP和UDP(都是传输层)的区别，适用场景：(1)TCP面向连接，UDP无连接(2)TCP可靠，UDP不可靠，TCP首部开销大(3)TCP面向字节流进行流量控制，UDP面向报文尽最大交付(4)TCP一对一，UDP可以一对多、多对多(5)适用场景TCP适用于小数据的可靠传输，UDP面向大数据传输。
26.系统设计题：数据预处理＋特征工程(特征选择)＋模型训练＋效果评估(模型选择)，数据预处理部分又包括正负样本不均衡情况下考虑重采样、分类特征onehot编码、连续特征归一化、离群值缺省值处理等，特征工程包括特征选择和特征组合。
27.常用排序算法有哪些？堆排是怎样的？大根堆是怎么去调整的？冒泡选择插入(希尔)桶排归并快排堆排。堆排通过构造二叉堆顶部比两个子树大，左右没有要求。sinkdown，swimup。
28.最短路径F算法和D算法：F算法每次寻找最近的路径连接上，D算法初始化一个路径矩阵，通过插点法更新更小路径。
29.用两个栈实现一个队列：一个用于倒腾，一个用于存储。
30.两个有序数组求第k小的数：(1)merge好后的第k个 (2)双指针pop，pop到第k个。(3)对数效率的解法。两个都去K/2处，相等就是找到了，不等就去掉小的那K/2，问题规模缩小到了K/2，重复。
31.求一个集合的所有子集：(1)一个一个来，生成两个，一个含有，一个不含有，维护Layers (2)递归的方式 subset = lambda a: [[]] if not a else subset(a[1:])+[[a[0]]+si for si in subset(a[1:])]
32.给一棵二叉搜索树(可以有重复，如果值相等只会在左子树)，再给一个数x，问小于等于x的节点有多少：中序遍历，计数器，遍历到x。
33.原子性：整个流程要么一起操作，要么一起不操作。如果不加锁，可能在寄存器上值被修改，不能保证原子性。
34.一致性hash：(1)取模hash算法：5万张图片分配到三台服务器，可以对3取模然后分配。但是增加或者减少了服务器怎么办，那就必须重新移动大量图片。(2)一致性hash算法：为三个服务器的ip对2的32次方进行取模，想象成一个环，5万张图片也是对2的32次方取模，之后顺时针找到最近的服务器位置放进去。增加节点时，更新一块区域，减少节点时，更新一块区域即可。但是，很容易在环上不均衡，比如有些服务器的区间特别小，可以增加一些虚拟节点来均衡，一个服务器对应多个节点。
35.布隆过滤器BloomFilter:存储效率高。存在的不能保证100%正确，不存在的一定不存在。设计多个hash函数映射到不同位上为1，进行检测。常用于爬虫记录已经爬过的网站。
36.给出因子为3，5，7至少一个的第k大的数:三个指针最小前向探索。
37.给出一个整数序列，判断他是否是二叉排序数的后续遍历：后续遍历要求最后一个是根节点，前面都比根大，后面都比根小，找到第一个划分后，对两个子问题进行递归，敏捷失败。
38.AVL最坏时树的深度为O(lgN).//因为是平衡的
39.图遍历复杂度：遍历可以用栈。不管DFS还是BFS，用邻接链表示是O(n+e),用邻接表（矩阵，数组）表示是O(n^2)
40.判断一个图是否有环：可以用DFS和拓扑排序，历史用hashset维护。不能用BFS，因为两个节点可以指向同一个节点，不能用最短路径算法，因为不影响。
41.给定数组，快速求出所有数右边第一个比其大的数：双指针法，前向搜索，敏捷成功；或者从后向前，后面先排好序。
42.四十亿个数排序：(1)分块各自排序，k路归并（胜者树）(2)位图法，按位(bit)，对应的位置置1。//类似桶排(3)MR中先扫描一下，sample出10000个数字，对其排序，确定100个reduce的上下界，分到100个reduce中各种排序，将100个reduce结果拼接一下。
43.从数据流中均匀概率采样k个数：蓄水池抽样：(1)在不知道文件总行数的情况下，如何从文件中随机的抽取一行,定义取出的行号为choice，第一次直接以第一行作为取出行 choice ，而后第二次以二分之一概率决定是否用第二行替换 choice ，第三次以三分之一的概率决定是否以第三行替换 choice.(2) 如何取k个：先把前k个数放入蓄水池，对第k+1，我们以k/(k+1)概率决定是否要把它换入蓄水池，换入时随机的选取一个作为替换项，这样一直做下去，对于任意的样本空间n，对每个数的选取概率都为k/n。
44.给定概率分布，产生随机数：蒙特卡罗，Gibbs采样。
45.求圆周率：蒙特卡洛法、积分、泰勒展开
46.验证码识别的可行方案：(1)打码平台，比如打码兔，进行人工打码(2)验证码识别API，或者调用百度识图等API(3)自己实现机器学习，类似手写数字识别，进行二值化，流形检测，拆开，SVM，CNN等。
47.生成器和协程：生成器用yield关键字构建，用next方法调用（python2和python3不大一样）。协程仍然是一个线程，仍然受到GIL的限制，同线程的区别是线程由操作系统调度，而协程由程序员操控。比如gevent，生产者消费者模型，等生产出来(yield)去消费。协程和线程适合IO密集型任务，多进程适合计算密集型任务。CPython中没有真正的多线程，因为GIL的限制，同时只能锁住一个线程。//有个包叫grequests，是结合了gevent的requests。
48.协程、多线程和多进程：(1)协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显式调度(2)线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(3)拥有自己独立的堆和栈，既不共享堆也不共享栈，进程由操作系统调度。(4)进程间如何通信：进程A地址空间里的一段内存数据，借助操作系统的帮助，拷贝到进程B的地址空间中（管道，信号，信号量，套接字，消息队列）。线程间如何通信：锁、信号、信号量。
49.进程与线程对比：(1)多线程的优点：开销小，共享资源容易。(2)多线程缺点：共用一个进程的资源，受限于单个CPU，不够稳定，需要加锁。(3)多进程优点：进程间独立，程序稳定，可以利用多CPU，可以尽量减少线程加锁/解锁的影响，极大提高性能(4)多进程缺点：进程间通信比较困难，开销大。(5)一般是多进程，进程里面开线程。
50.介绍mapreduce：任务分解来解决并合并结果的思想。比如wordcount，通过flatmap并行的将每句话按空格切分单词，并且制作成key-value的形式，(a,1)，(b,1)的形式。shuffle的过程可以分布式的进行分区分组排序。reduce的过程可以将结果通过一个key聚集在一起计算，(a,3),(b,2)。reducebykey和groupbybykey的区别，reducebykey在每个机器计算了本地结果，之后汇总，而groupbykey一般要先聚集到某个机器，应该尽量避免groupbykey。写完rdd的map和reduce操作之后，并不是立刻进行计算，需要计算的时候才会进行计算，比如collect的时候。
51.请问0-9999中有多少个1：考虑补成等长4位数共有40000位，10个群体是对称的，其中有4000个1.
```